{
  "$schema":"http://json-schema.org/draft-04/schema#",
  "description":" h2server configuration",
  "title":"h2server_configuration",
  "type":"object",
  "properties":{
    "address":{
      "description":"IP address",
      "default": "0.0.0.0",
      "type":"string"
    },
    "port":{
      "description":"port, 80, 443 ,etc.",
      "default": 80,
      "type":"integer"
    },
    "threads":{
      "description":"Number of concurrent worker threads. If 0 is given: thead number matches number of cores",
      "default": 1,
      "type":"integer"
    },
    "private-key-file":{
      "description":"path to private key file",
      "type":"string"
    },
    "cert-file":{
      "description":"path to cert file",
      "type":"string"
    },
    "verbose":{
        "description": "true: print debug trace; false: no debug print",
        "default": false,
        "type":"boolean"
    },
    "Service":{
      "description":"service is a list of Request and Response pairs. Each response is associated with a Request, while the Request specifies the pattern the incoming request message should have, and if the incoming request matches the specified pattern, the corresponding Response is returned as the response of the incoming request message; if the incoming request can match more than one patterns, the request pattern with more matching rules is chosen",
      "type":"array",
      "minItems":1,
      "items": {
        "type": "object",
        "description":"A pair of Request and Response",
        "properties":{
          "Request":{
            "description": "Request specifies the desired pattern that a incoming request message should have, which includes a list of match rules of received headers, and optionally a list of match rules of Json payload; if a request message passes all the header match rules as well as the payload match rules, then the corresponding content specified by Response would be returned as the response",
            "type":"object",
            "properties":{
              "headers":{
                "description": "Match to be executed against the received headers",
                "type":"array",
                "minItems":1,
                "items": {
                  "type": "object",
                  "description": "Match to be executed against one received header",
                  "properties":{
                    "header-name":{
                      "description": "This field specifies the name of a received header; the value of this header is to be picked up to run the match",
                      "default": ":path",
                      "type":"string"
                    },
                    "matchType":{
                      "type":"string",
                      "description": "Type of match action",
                      "default": "StartsWith",
                      "enum": ["EqualsTo", "StartsWith", "EndsWith", "Contains"]
                    },
                    "input":{
                      "description": "Content used to run the matchType above against the received header value; i.e., received header value should either equal to or start with or end with or contain the content specified in this field",
                      "default": "/",
                      "type":"string"
                    }
                  }
                }
              },
              "payload": {
                "description": "Array of matches to be executed against the received Json payload; only if all matches here are successful, the payload match is considered successful",
                "type":"array",
                "minItems":0,
                "items": {
                  "type": "object",
                  "description": "One match action to be executed against the received Json payload",
                  "properties":{
                    "JsonPointer": {
                      "description": "A Json pointer to locate a value within the received Json payload",
                      "type":"string"
                    },
                    "matchType": {
                      "type":"string",
                      "description": "Type of match action",
                      "enum": ["EqualsTo", "StartsWith", "EndsWith", "Contains"]
                    },
                    "input": {
                      "description": "Content used to execute the matchType above against the value specified by the Json pointer above; the value specified by the Json pointer above should either equal to or start with or end with or contain the content specified in this field",
                      "type":"string"
                    }
                  }
                }
              }
            },
            "required":[
              "headers"
            ]
          },
          "Response":{
            "description": "Response message to be returned in response to the request above",
            "type":"object",
            "properties":{
              "status-code": {
                "description": "status-code",
                "default": 200,
                "type": "integer"
              },
              "payload": {
                "description": "response payload",
                "type":"object",
                "properties":{
                  "msg-payload": {
                    "description": "The actual message payload. The payload can optionally contain a placeholder (name specified below) that has multiple occurrences. For example: {'name': '$VAR', 'location': '$VAR', 'ID', '$VAR'}, here, $VAR is the placeholder. Each occurrence of $VAR would be replaced by an actual string as instructed by arguments field, in order of occurrance; no need to manually add Content-Length header in additonalHeaders field, as it would be generated based on the actual final length; however, Content-Type header should be provided by user manually in additonalHeaders field.",
                    "type":"string"
                  },
                  "placeholder": {
                    "description": "A string that is embeded in msg-payload above acting as placeholders, for example, $VAR",
                    "type":"string"
                  },
                  "arguments": {
                    "description": "A list of arguments. The result of first argument would replace the first placeholder occurrence in header, and the result of second argument would replace the second placeholder occurrence, and so on. The number of arguments here should match the number of placeholder occurrences above",
                    "type":"array",
                    "minItems":0,
                    "items": {
                      "type": "object",
                      "description": "Each argument produces a string value; the value can be identified by a Json pointer to the payload of the corresponding request, or value of a header in the corresponding request; the string value can also be a random single hex number, e.g., A, or B, or 9, etc., and a chain of random hex argument can be used to generate a UUID. An optional substring action specified by sub-string-start and sub-string-length can be applied to cut the value to get the desired portion, this is usually useful when the value is from Json pointer or header, it is obviously not making sense to cut the value which is already a single hex",
                      "properties":{
                        "type-of-value": {
                          "description": "how to produce the value: JsonPointer means to find the value from the received Json payload with the Json pointer specified by value-identifier field; Header means the value of the request header, with header name specified by value-identifier field; RandomHex means to generate a random hex number, like A, B, C, 9, etc.; TimeStamp is to generate a timestamp in IMF-fixdate format, e.g.: Sun, 06 Nov 1994 08:49:37 GMT",
                          "type":"string",
                          "enum": ["JsonPointer", "Header", "RandomHex", "TimeStamp"]
                        },
                        "value-identifier":{
                          "description": "Either a Json pointer, e.g., /name representing 'bill' in {'name': 'bill', 'location': office', 'ID', '123'}; or a header name which points to a header of the received request; this field is not used if type-of-value is neither JsonPointer nor Header",
                          "type":"string"
                        },
                        "sub-string-start":{
                          "description": "the start position from which the substring action would pick up the substring; default: 0, meaning the start of the string",
                          "default": 0,
                          "type": "integer"
                        },
                        "sub-string-length":{
                          "description": "the length of the sub-string, -1 means till the end of the whole string; so sub-string-start = 0, sub-string-length = -1, means the whole string is taken, with no sub-strinng operation done",
                          "default": -1,
                          "type": "integer"
                        }
                      }
                    }
                  }
                }
              },
              "additonalHeaders":{
                "description": "additional headers to be returned.",
                "type": "array",
                "minItems":0,
                "items": {
                  "type":"object",
                  "properties":{
                    "header": {
                      "description": "Valid format for each header: a pair of strings with colon (:) in the middle; for example: Content-type: Application/json. The value part, which is after the colon, can optionally contain a placeholder (name specified below) that has multiple occurrences. For example: location:http://192.168.1.2.3.4/$VAR, here, $VAR is the placeholder. Each occurrence of $VAR would be replaced by an actual string as instructed by arguments field, in order of occurrance",
                      "type":"string"
                    },
                    "placeholder": {
                      "description": "A string that is embeded in header above acting as placeholders, for example, $VAR",
                      "type":"string"
                    },
                    "arguments": {
                      "description": "A list of arguments. The result of first argument would replace the first placeholder occurrence in header, and the result of second argument would replace the second placeholder occurrence, and so on. The number of arguments here should match the number of placeholder occurrences above",
                      "type":"array",
                      "minItems":0,
                      "items": {
                        "type": "object",
                        "description": "Each argument produces a string value; the value can be identified by a Json pointer to the payload of the corresponding request, or value of a header in the corresponding request; the string value can also be a random single hex number, e.g., A, or B, or 9, etc., and a chain of random hex argument can be used to generate a UUID. An optional substring action specified by sub-string-start and sub-string-length can be applied to cut the value to get the desired portion, this is usually useful when the value is from Json pointer or header, it is obviously not making sense to cut the value which is already a single hex",
                        "properties":{
                          "type-of-value": {
                            "description": "how to produce the value: JsonPointer means to find the value from the received Json payload with the Json pointer specified by value-identifier field; Header means the value of the request header, with header name specified by value-identifier field; RandomHex means to generate a random hex number, like A, B, C, 9, etc.; TimeStamp is to generate a timestamp in IMF-fixdate format, e.g.: Sun, 06 Nov 1994 08:49:37 GMT",
                            "type":"string",
                            "enum": ["JsonPointer", "Header", "RandomHex", "TimeStamp"]
                          },
                          "value-identifier":{
                            "description": "Either a Json pointer, e.g., /name representing 'bill' in {'name': 'bill', 'location': office', 'ID', '123'}; or a header name which points to a header of the received request; this field is not used if type-of-value is neither JsonPointer nor Header",
                            "type":"string"
                          },
                          "sub-string-start":{
                            "description": "the start position from which the substring action would pick up the substring; default: 0, meaning the start of the string",
                            "default": 0,
                            "type": "integer"
                          },
                          "sub-string-length":{
                            "description": "the length of the sub-string, -1 means till the end of the whole string; so sub-string-start = 0, sub-string-length = -1, means the whole string is taken, with no sub-strinng operation done",
                            "default": -1,
                            "type": "integer"
                          }
                        }
                      }
                    }
                  }
                }
              },
              "luaScript": {
                "type":"string",
                "description": "lua script (or a filename containing the actual script) with a function named customize_response, handling 4 arguments: request_headers (a table), request_payload, response_headers (a table), response_payload; returning request_headers_to_send and request_payload_to_send. maock passes the matched request headers and payload, and the response headers and payload generated above, to this lua function, which can update the response headers and response payload, and maock will use the updated headers and payload for the response. Example script: function customize_response(request_header, request_payload, response_headers_to_send, response_payload_to_send) return response_headers_to_send, response_payload_to_send end"
              }
            }
          }
        },
        "required":[
           "Request",
           "Response"
        ]
      }
    }
  },
  "required":[
    "Service"
  ]
}
